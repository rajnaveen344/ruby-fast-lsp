//! Build script to embed RBS type definitions into the binary.
//!
//! This script reads all .rbs files from rbs_types/ and generates a Rust
//! module that contains them as static byte arrays, so they're available at
//! runtime without needing the files on disk.

use std::env;
use std::fs::{self, File};
use std::io::{BufWriter, Write};
use std::path::Path;

fn main() {
    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("embedded_rbs.rs");
    let mut file = BufWriter::new(File::create(&dest_path).unwrap());

    // Start the generated module
    writeln!(
        file,
        "// Auto-generated module containing embedded RBS type definitions."
    )
    .unwrap();
    writeln!(file, "// DO NOT EDIT - generated by build.rs").unwrap();
    writeln!(file).unwrap();

    // Collect all RBS files from core/
    let manifest_dir = env::var("CARGO_MANIFEST_DIR").unwrap();
    let core_path = Path::new(&manifest_dir).join("rbs_types/core");

    let mut core_files: Vec<(String, Vec<u8>)> = Vec::new();
    if core_path.exists() {
        collect_rbs_files(&core_path, &core_path, &mut core_files);
    }

    // Generate the CORE_RBS_FILES array using byte arrays
    writeln!(
        file,
        "/// Embedded core RBS files (class name, content as bytes)"
    )
    .unwrap();
    writeln!(file, "pub static CORE_RBS_FILES: &[(&str, &[u8])] = &[").unwrap();
    for (name, content) in &core_files {
        write!(file, "    (\"{}\", &[", name).unwrap();
        for (i, byte) in content.iter().enumerate() {
            if i > 0 {
                write!(file, ", ").unwrap();
            }
            write!(file, "{}", byte).unwrap();
        }
        writeln!(file, "]),").unwrap();
    }
    writeln!(file, "];").unwrap();
    writeln!(file).unwrap();

    // Collect stdlib files
    let stdlib_path = Path::new(&manifest_dir).join("rbs_types/stdlib");
    let mut stdlib_files: Vec<(String, Vec<u8>)> = Vec::new();
    if stdlib_path.exists() {
        collect_rbs_files(&stdlib_path, &stdlib_path, &mut stdlib_files);
    }

    // Generate the STDLIB_RBS_FILES array
    writeln!(
        file,
        "/// Embedded stdlib RBS files (relative path, content as bytes)"
    )
    .unwrap();
    writeln!(file, "pub static STDLIB_RBS_FILES: &[(&str, &[u8])] = &[").unwrap();
    for (name, content) in &stdlib_files {
        write!(file, "    (\"{}\", &[", name).unwrap();
        for (i, byte) in content.iter().enumerate() {
            if i > 0 {
                write!(file, ", ").unwrap();
            }
            write!(file, "{}", byte).unwrap();
        }
        writeln!(file, "]),").unwrap();
    }
    writeln!(file, "];").unwrap();

    // Tell Cargo to rerun if RBS files change
    println!("cargo:rerun-if-changed=rbs_types/");
}

fn collect_rbs_files(base_path: &Path, current_path: &Path, files: &mut Vec<(String, Vec<u8>)>) {
    if let Ok(entries) = fs::read_dir(current_path) {
        for entry in entries.flatten() {
            let path = entry.path();
            if path.is_dir() {
                collect_rbs_files(base_path, &path, files);
            } else if path.extension().is_some_and(|ext| ext == "rbs") {
                if let Ok(content) = fs::read(&path) {
                    // Get relative path from base
                    let relative = path.strip_prefix(base_path).unwrap_or(&path);
                    let name = relative.to_string_lossy().to_string();
                    files.push((name, content));
                }
            }
        }
    }
}
